import copy
import numpy as np
import random
import gurobipy as grb
from gurobipy import GRB


### begin data processing
# read instances file line by line
with open('test.txt') as file:
    lines = file.readlines()

# initialize variables
G = {}
data = []
weights = []
vertices = []
index = 0

# process input data
for line in lines:

    line = line.split()
    line = [int(i) for i in line]

    # first line has 2 entries corresponding to # of nodes and edges
    if len(line) == 2:
        n = line[0]
        m = line[1]

    # lines with 3 entries include info (head tail weight) for each edge
    # create graph/dictionary of edge info called G
    if len(line) == 3:
        data.append(line) # keep original edge format for output
        weights.append(line[2]) # keep weight info for output
        weight = line[2]
        head = line[0] # head node
        tail = line[1] # tail node
        if head not in G:
            G[head] = {}
        if tail not in G:
            G[tail] = {}
        # can travel either direction on each edge
        G[head][tail] = index, weight
        G[tail][head] = index, weight
        index += 1 # update edge index

# create list of vertex indices (needed for merge function)
for i in range(n):
    vertices.append(i)
### end data processing


### begin functions
# function to merge two vertices (used in minimumcutphase)
def merge(G, s, t):

    # store neighbor and edge info about each vertex 
    Ns = copy.deepcopy(G[s])	
    Nt = copy.deepcopy(G[t])

    # account for shared neighbors of s and t
    N = [n for n in Ns.keys() if n in Nt.keys()]
	
    # remove edges connecting other vertices to s and t (including edges between s and t)
    # update set of edge indices still in use
    for n in Ns:
        del G[n][s]
    for n in Nt:
        del G[n][t]

    # delete s and t everywhere and update existing vertices
    vertices.remove(s); vertices.remove(t)
    del Ns[t]; del Nt[s]; del G[s]; del G[t]
	
    # make sure s and t have the same type so we can merge them 
    if type(s) == int:
        s = frozenset([s])
    if type(t) == int:
        t = frozenset([t])

    # replace s and t by new vertex 
    st = s.union(t)
    vertices.append(st)
    G[st] = {}

    # edges from s or t to another vertex are replaced by edge weighted with sum of the weights of the previous edge(s)
    # state both ways to ensure symmetry
    for n in N:
        G[st][n] = None, Ns[n][1] + Nt[n][1] # no edge index since we've created a brand new edge
        G[n][st] = None, Ns[n][1] + Nt[n][1]
    for n in Ns:
        if n not in N:
            G[n][st] = Ns[n]
            G[st][n] = Ns[n]
    for n in Nt:
        if n not in N:
            G[n][st] = Nt[n]
            G[st][n] = Nt[n]

    return G

# based on reference paper
# function to find cut-of-the-phase
def minimumcutphase(G, a):
    
    A = [a]
    V = vertices

    # a subset A of our vertices grows until A is equal to the set of all vertices V
    while set(A) != set(V):

        # initialize variables
        maxweight = 0
        z = None

        # find the most tightly connected vertex outside of A
        for v in G:
            weight = 0
            if v not in A:
                for u in A:
                    if u in G[v]:
                        weight += G[u][v][1] # update weight for each adjacent edge
                if weight > maxweight:
                    maxweight = weight
                    z = v # z is most tightly connected vertex so far

        A.append(z)

    # cut the last vertex from the rest of the graph and find weight of that cut
    lastvertex = A[-1]
    weight = 0
    for n in G[lastvertex]:
        weight += G[lastvertex][n][1]

    # define our cut-of-the-phase, could be integer or frozenset
    if type(lastvertex) == int:
        cut = [lastvertex]
    if type(lastvertex) == frozenset:
        cut = list(lastvertex)

    # merge last two vertices
    G = merge(G, A[-1], A[-2])

    return G, weight, cut

# based on reference paper
# find lightest cut-of-the-phase, aka the minimum cut, and weight of that cut
def minimumcut(G):

    # initialize variables
    mincut = []
    minweight = float('inf') # arbitrarily large

    # use copy of G so we don't alter the original
    H = copy.deepcopy(G)

    # apply minimum cut phase algorithm
    # repeat until G has only one vertex remaining
    while len(vertices) > 1:
        print(vertices)
        # choose starting vertex a arbitrarily
        a = random.choice(vertices)
        H, weight, cut = minimumcutphase(H, a)

        if weight < minweight:
            mincut = cut # lightest cut-of-the-phase so far
            minweight = weight

    return mincut, minweight

# function to create model constraints for subtour elimination
def subtourelimination(G):
	
    # apply minimum cut algorithm using first vertex arbitrarily
    mincut, minweight = minimumcut(G)

    # if weight of minimum cut is less than 2 we violated a subtour elimination constraint
    cutweight = 0
    for u in mincut:
        for v in G[u]:
            if v not in mincut:
                i = G[u][v][0]
                cutweight += model.X[i]

    print(cutweight)
    if cutweight < 2:
        model.addConstr(grb.quicksum(model.X[i] for i in mincut) >= 2)
        model.update()    

    return mincut, minweight
### end functions



### begin model 
model = grb.Model()

# lp relaxation of binary constraint indicating if each edge is in tour or not
x = model.addVars(m, lb=0.0, ub=1.0, vtype=GRB.CONTINUOUS)
model.update()

# if weight of minimum cut is less than 2 we violated a subtour elimination constraint
model.addConstr(grb.quicksum(model.getVars()) >= 2)
model.update()

# objective is to minimize weight of our tour 
model.setObjective(np.dot(model.getVars(), np.transpose(weights)))
model.update()
model.optimize(subtourelimination(G))
### end model

print(model.ObjVal)
print(model.X)


### begin output
print('Best tour:')
for i in range(m):
    if model.X[i] > 0.5:
        print(data[i])
print()
print('The cost of the best tour is: ' + str(model.ObjVal))
### end output
